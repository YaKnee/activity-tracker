# activity-tracker
React project to track activity

## Requirements
- [ ] (•	The submission has been done as a .zip package. When unzipped into a directory, this directory should work directly as the project directory. (This means that you should zip the relevant content of your project directory into a zip file, not add your project directory into a zip file so that when unzipped into a directory, there is your project directory within this directory.)
- [ ] (•	The application has at least three separate “views” with different content, and the user is able to keep switching between the views easily using a menu (a dropdown menu or a menu bar), tabs, or buttons within the user interface of the application.)
    •	The application has an “Info” (or “About”) menu option or button, via which the user can get information on the application. At least these pieces of information must be available via this functionality:
    •	The name of the author
    •	Short instructions for using the application. If instructions are unnecessary – i.e., you are sure that your UI is extremely easy to use and understandable intuitively – this state of matters must be mentioned explicitly, then. (The info can contain, e.g., the statement “The UI hints help the user to figure out how to use the application,” “Using the application should be intuitive and straightforward,” or something else suitable.)
    •	If all the (possible) pictures and other such content used in your application are originally created by you yourself, tell it here explicitly. Otherwise, mention the licenses/permissions under which you use content from external sources. Make sure that the possible license conditions actually allow such use and you fulfil all the related requirements. (The application code itself must, naturally, be written by you.) N.B. Something relating to this bullet must be written always regardless to what kind of content your application uses or does not use.
    •	Information about the AI tools that have been used and how and for what / explicit note about AI tool not having been used.
    •	How many working hours, approximately, did you spend working with this programming assignment? (The number does not affect the grading, but this is asked in order to understand the work load so that adjustments can be made in the future, if necessary. Therefore, honest answers are appreciated.)
    ▪	This is just an estimate, but it must be expressed as one integer number of hours spent. (I.e., NOT as some interval like 30–40 hours or some estimate expressed in days or working weeks or anything else than hours.)
    •	What did you consider as the most difficult/tedious feature to implement?

    (Note: One of the views required by Module A may, for instance, be an info page presenting the necessary information required by this module, but you are free to implement this otherwise, also.) )
- [ ] (•	The application can communicate with a simple local backend server*, and by using an API offered by it initialize the application: when the application starts (the page is loaded), it must automatically (i.e., without any input by or interaction with the user) fetch from the back end information about tasks. Especially, for each task existing in the system, the application must get at least its
    •	name (an arbitrary** string, e.g., “code”, “fix the computer”, or “feed the cat”) and
    •	the related tags. A task must be able to have several. (Tags (e.g., “school”, “animal care”, and “cool”) may be used to categorize and describe tasks.)
    •	Based on the fetched data, the application must show corresponding task elements, implemented as React components, within its UI. (Task elements are visible representations of the tasks, and the user can interact with them via the UI.) There must be one task element for each task, and the name and the tags of a task must be represented visually by the corresponding task element always when it is visible.

    * You are not to implement this yourself for this assignment. This backend server functionality is obtained by using a simple server offered separately for this task (along with the necessary instructions to use it). The server should be run on the localhost on port 3010.

    ** You are allowed to limit the maximum length, but at least 40-character names must be supported. )

- [ ] (•	Via the application UI, the user must be able to...
    •	add new task elements to be shown within the UI (defining their names and the associated tags), and
    •	remove task elements one by one in an arbitrary order.
    (A task element is a visual representation of a task known by the application, and adding and removing task elements can be seen as adding and removing the corresponding (abstract) tasks from the system.))

- [ ] (    •	Via the application UI, the user is also able to...
    •	freely edit the task names shown in the task elements,
    •	add tags to and remove them from task elements arbitrarily one by one, and
    •	create new tags (by defining arbitrary strings – possibly along with some additional data that might be needed (e.g., presentation color) – to be used as such).
    
    It is not sufficient to be able to perform these activities when adding a new task element, but they must be enabled for any task element at any time.)

 
•	The changes made by the user via the application UI (concerning task elements) are stored using suitable API calls to the back end so that the application can fetch the changed data successfully on start (see Module C). The application can store information automatically and continuously (when changes are made) or only when the user explicitly asks for it via the UI (e.g., pushes a Save button).
•	The user can, via the application UI, filter task elements based on their tags. I.e., the user must be able to limit the selection of task elements to be shown so that only the task elements with the desired (arbitrary) tags are shown and the other task elements are hidden. The user can select several tags, and only those task elements having all of those tags are shown. The user must also be able to see all the task elements regardless to their tags.
•	Handling tags has been implemented so that when adding a tag for a task element, the user is not always required to write the tag text, but it is possible to select among the existing tags that have already been created before.
•	The user can rearrange task elements within the UI. (The idea is that the mutual visual presentation order of the elements can be changed arbitrarily; e.g., automatic layout changes based on the size of the screen are thus not enough to fulfil this requirement.)
•	Each visible task element must always (without any extra operations performed by the user) clearly show whether the task is active at the moment or not. Being active means that time used for the respective task is currently recorded – the idea is that someone is just performing the activities related to this task, and the overall time used for this task keeps increasing until the task becomes inactive (i.e., performing the related activity is stopped).
•	If a task is inactive (i.e., time is not counted for it), the user can easily (using a functionality offered by the corresponding task element) activate it (make it active, i.e., start/continue counting time for it). Correspondingly, an active task can easily be deactivated (made inactive, i.e., pause counting time for it. (In other words, the count is stopped (without initializing it in any way) until the next possible activation.)
•	The application stores, using the API provided by the server – see Module C – activation and deactivation times so that when the application is started the next time, counting time continues automatically for the active tasks (the tasks that have been activated without having been deactivated since) exactly as it would continue if the application had been running for whole the time. (The application assumes that tasks can be activated/deactivated only when it is running.)
•	Several (unlimited number of) tasks can be active simultaneously.
•	The user can specify and freely modify an arbitrary observation interval from a start moment (starting date and time) to an end moment (ending date and time). By default, this interval covers the current day from its beginning to the current time. Minute resolution or more precise one (e.g., second resolution) must be used – dealing with, e.g., full hours only is not a sufficient precision. Let us call tasks that have been active at some point during the observation interval tasks of interest and tags associated with these tasks tags of interest.
•	The user can easily see a summary about the total active times (sums of durations of individual activity periods) separately for each task of interest and each tag of interest within the observation interval. The other tasks or tags than tasks of interest and tags of interest are not to be shown in the summary. (Their total active times within the observation interval are known to be zero, anyway.)
•	The user can specify and freely modify an arbitrary task details interval from a start moment (starting date and time) to an end moment (ending date and time). By default, this interval covers the current day from its beginning to the current time.
•	The user can select any task and see a list of distinct time intervals (activity intervals) when that particular task has been active. (For these intervals, at least the start and end times must be shown.) Exactly and only those activity intervals should be listed that at least partially overlap the task details interval. (However, a listed activity interval can start before the start of task details interval or end after its end as far as there is some overlap.) Activity intervals must be listed in chronological order (by their starting moments).
 
(If the task details interval covers the current moment and ends in the future when the task under observation is currently active, any end time should not be shown for the ongoing activity interval, because one does not know, when the task will be deactivated.)
•	Regarding the list required by Module K, the user can add new activity intervals on the list and remove selected activity intervals from it. The user can also modify the starting and ending times of the listed activity intervals and save all the manual changes regarding them using the API offered by the server (see Module C).
•	If there are time overlaps regarding some of the listed activity intervals, these problematic intervals must be pointed out on the list visually (e.g., by using a different color for them).

Any special error handling is not required, but if the changes made by the user make sense (the intervals remain distinct etc.), the application keeps working in a sensible way and uses the modified values correctly.
•	The user can select a task, specify an arbitrary interval of (whole) days (daily activity chart interval), and see a bar chart depicting daily active times concerning the selected task (daily sums of durations of activity intervals for the task). There should be a bar per day, and only activity taking place during daily activity chart interval counts – other activity is not taken into account, and the days outside daily activity chart interval are not included in the chart.
•	The user can access an “Options” or “Settings” view/dialog, in which the user can at least
•	change the theme of the application (must clearly affect at least the UI colors) and
•	change the application into an alternative mode in which only one task can be active at a time (activating a task deactivates the other tasks) and back into the default mode.
The settings must be stored via the API provided by the server (see Module C). (Do not use, e.g., localStorage.) When you submit your work, the default mode (in which several tasks can be active) must be used, but after that, the application must always start with the most recently set configuration.)

(Note: One of the views required by Module A may, for instance, be this Settings page, but you are free to implement this otherwise, also.)
•	The user interface is responsive and supports different screen resolutions. One must be able to use the application in a small browser window of width of only 500 px, but if wider screen in available, the extra space must be used sensibly. Merely scaling the elements is not considered to be “responsiveness,” but the layout must change reasonably based on the screen size (e.g., by adjusting the orientations/locations of elements that are shown and/or hiding nonessential information).
•	The application feels usable and accessible. When using the application with a PC, all the features can be efficiently used with keyboard only (without a mouse or other such pointing device). The font sizes are suitable, and the color contrasts meet the WCAG AA requirements (see, e.g., https://developer.mozilla.org/en-US/docs/Web/Accessibility/Understanding_WCAG/Perceivable/Color_contrast). (It is a good idea to take advantage of the accessibility tools of a browser when implementing your application and checking the accessibility.)
